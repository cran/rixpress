<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Effective Debugging</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Effective Debugging</h1>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This vignette will guide you through the primary debugging workflow
in <code>{rixpress}</code>, covering how to:</p>
<ol style="list-style-type: decimal">
<li>Inspect the error messages from a failed build.</li>
<li>Trace the dependency graph to find structural problems.</li>
<li>Isolate specific parts of the pipeline for focused debugging.</li>
<li>Access logs from previous builds to investigate regressions.</li>
</ol>
</div>
<div id="the-first-response-to-a-failed-build-rxp_inspect" class="section level2">
<h2>The First Response to a Failed Build:
<code>rxp_inspect()</code></h2>
<p>Imagine you have just run <code>rxp_make()</code> and are greeted
with an error message in your console.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>Build process started...</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="sc">+</span> <span class="er">&gt;</span> mtcars building</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="sc">+</span> <span class="er">&gt;</span> mtcars_am building</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="sc">+</span> <span class="er">&gt;</span> mtcars_head building</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>x mtcars_head errored</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>✓ mtcars built</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>✓ mtcars_am built</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="sc">!</span> pipeline completed [<span class="dv">2</span> completed, <span class="dv">1</span> errored]</span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a>Build failed<span class="sc">!</span> Run <span class="st">`</span><span class="at">rxp_inspect()</span><span class="st">`</span> <span class="cf">for</span> a summary.</span></code></pre></div>
<p>The build has failed. Your immediate next step should always be to
run <code>rxp_inspect()</code>. By default, this function reads the most
recent build log, which in this case is the one from our failed run.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">rxp_inspect</span>()</span></code></pre></div>
<p>This will return a data frame summarizing the status of every
derivation in the pipeline. Let’s look at a hypothetical output:</p>
<pre><code>       derivation build_success                                               path    output
1 all-derivations         FALSE /nix/store/j5...-all-derivations       mtcars_head
2       mtcars_am          TRUE /nix/store/a4...-mtcars_am                  mtcars_am
3     mtcars_head         FALSE                                      &lt;NA&gt;          &lt;NA&gt;
4          mtcars          TRUE /nix/store/b9...-mtcars                       mtcars
                                              error_message
1                                                      &lt;NA&gt;
2                                                      &lt;NA&gt;
3 Error: function &#39;headd&#39; not found\nExecution halted\n
4                                                      &lt;NA&gt;</code></pre>
<p>The two most important columns for debugging are
<code>build_success</code> and <code>error_message</code>.</p>
<ul>
<li><code>build_success</code>: This
<code>TRUE</code>/<code>FALSE</code> column immediately tells you which
derivation failed. In our example, <code>mtcars_head</code> is the
culprit.</li>
<li><code>error_message</code>: This column contains the standard error
output captured from the Nix build process. It provides the exact reason
for the failure. Here, the message
<code>&quot;Error: function &#39;headd&#39; not found&quot;</code> points to a simple typo
in our R code.</li>
</ul>
<p>By pinpointing the specific derivation and providing the raw error
message, <code>rxp_inspect()</code> eliminates guesswork and directs you
straight to the source of the problem.</p>
</div>
<div id="investigating-structural-issues-with-rxp_trace" class="section level2">
<h2>Investigating Structural Issues with <code>rxp_trace()</code></h2>
<p>Sometimes, a pipeline fails not because of a typo in a single
derivation, but because of a logical error in how the derivations are
connected. <code>rxp_trace()</code> is the tool for diagnosing these
structural issues. It reads the pipeline’s dependency graph
(<code>dag.json</code>) and helps you answer questions like:</p>
<ul>
<li>“What steps must run before this one?” (Dependencies)</li>
<li>“If I change this step, what other steps will be affected?” (Reverse
Dependencies)</li>
</ul>
<p>For instance, if <code>mtcars_mpg</code> is producing an unexpected
result, you can trace its lineage:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">rxp_trace</span>(<span class="st">&quot;mtcars_mpg&quot;</span>)</span></code></pre></div>
<p>This might return:</p>
<pre><code>==== Lineage for: mtcars_mpg ====
Dependencies (ancestors):
  - filtered_mtcars
    - mtcars*

Reverse dependencies (children):
  - final_report

Note: &#39;*&#39; marks transitive dependencies (depth &gt;= 2).</code></pre>
<p>This output clearly shows that <code>mtcars_mpg</code> depends
directly on <code>filtered_mtcars</code> and indirectly (transitively)
on <code>mtcars</code>. It also shows that <code>final_report</code>
depends on it. If you expected <code>mtcars_mpg</code> to depend on a
different intermediate object, this trace would immediately reveal the
mistake in your pipeline definition.</p>
<p>Calling <code>rxp_trace()</code> without any arguments will print the
entire dependency tree, which is useful for getting a high-level
overview of your project’s structure.</p>
<p>You could instead plot the DAG using <code>rxp_ggdag()</code> for
example, but if the project is large, reading the DAG could be
difficult. <code>rxp_trace()</code> should be more useful in these
cases.</p>
</div>
<div id="a-proactive-strategy-isolating-derivations-with-noop_build" class="section level2">
<h2>A Proactive Strategy: Isolating Derivations with
<code>noop_build</code></h2>
<p>When debugging or prototyping, you often need to make frequent
changes to an early step in your pipeline. If a slow, computationally
expensive derivation depends on this changing step, your development
cycle can become painfully slow. Because Nix’s caching is based on
inputs, any change to an upstream step will invalidate the cache for all
downstream steps. Imagine a pipeline where you are tuning a data
preprocessing step, which is then followed by a lengthy model training
process:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">list</span>(</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="co"># We are actively changing the filter condition in this step</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="fu">rxp_r</span>(</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>    <span class="at">name =</span> preprocessed_data,</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>    <span class="at">expr =</span> <span class="fu">filter</span>(raw_data, year <span class="sc">&gt;</span> <span class="dv">2020</span>)</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>  ),</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  <span class="co"># This step takes hours to run</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>  <span class="fu">rxp_r</span>(</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>    <span class="at">name =</span> expensive_model,</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>    <span class="at">expr =</span> <span class="fu">run_long_simulation</span>(preprocessed_data)</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>  ),</span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>  <span class="fu">rxp_rmd</span>(</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>    <span class="at">name =</span> final_report,</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>    <span class="at">rmd_file =</span> <span class="st">&quot;report.Rmd&quot;</span> <span class="co"># Depends on expensive_model</span></span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>  )</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>)</span></code></pre></div>
<p>In this scenario, every time you adjust the filter() condition in
preprocessed_data, Nix correctly invalidates the cache for
expensive_model. This means the hours-long simulation will be
re-triggered with every small change, making it impossible to iterate
quickly on the preprocessing logic. This is the perfect use case for
noop_build = TRUE. By applying it to the expensive downstream step, you
temporarily break the dependency chain:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">list</span>(</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="co"># We can now change this step as much as we want</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  <span class="fu">rxp_r</span>(</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>    <span class="at">name =</span> preprocessed_data,</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>    <span class="at">expr =</span> <span class="fu">filter</span>(raw_data, year <span class="sc">&gt;</span> <span class="dv">2020</span>)</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>  ),</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>  <span class="co"># This and all downstream steps will be skipped</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>  <span class="fu">rxp_r</span>(</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>    <span class="at">name =</span> expensive_model,</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>    <span class="at">expr =</span> <span class="fu">run_long_simulation</span>(preprocessed_data),</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>    <span class="at">noop_build =</span> <span class="cn">TRUE</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>  ),</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>  <span class="fu">rxp_rmd</span>(</span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>    <span class="at">name =</span> final_report,</span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>    <span class="at">rmd_file =</span> <span class="st">&quot;report.Rmd&quot;</span> <span class="co"># Also becomes a no-op</span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>  )</span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a>)</span></code></pre></div>
<p>Now, when you run <code>rxp_make()</code>,
<code>preprocessed_data</code> will build as normal. However,
<code>expensive_model</code> will resolve to a no-op build, and because
<code>final_report</code> depends on it, it will also become a no-op.
This allows you to rapidly iterate on and validate the
<code>preprocessed_data</code> logic in isolation, without waiting for
the simulation to run. Once you are satisfied with the preprocessing,
simply remove <code>noop_build = TRUE</code> to re-enable the full
pipeline and run the expensive model training with your finalized
data.</p>
</div>
<div id="historical-debugging-going-back-in-time" class="section level2">
<h2>Historical Debugging: Going Back in Time</h2>
<p>When iterating quickly, it might be useful to compare results to the
ones obtained from previous runs. It is possible to check results from
previous runs using the logs.</p>
<p>First, use <code>rxp_list_logs()</code> to see the build history:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">rxp_list_logs</span>()</span></code></pre></div>
<pre><code>                                                        filename   modification_time size_kb
1 build_log_20250815_113000_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6.rds 2025-08-15 11:30:00    0.51
2 build_log_20250814_170000_z9y8x7w6v5u4t3s2r1q0p9o8n7m6l5k4.rds 2025-08-14 17:00:00    0.50</code></pre>
<p>You can see a successful build from yesterday
(<code>20250814</code>). To find out the differences with today’s
results, you can inspect that specific log by providing a unique part of
its filename to <code>which_log</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># Inspect yesterday&#39;s successful build log</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="fu">rxp_inspect</span>(<span class="at">which_log =</span> <span class="st">&quot;20250814&quot;</span>)</span></code></pre></div>
<p>This allows you to compare yesterday’s build summary with today’s
one. Furthermore, you can use <code>rxp_read()</code> with
<code>which_log</code> to load the <em>actual artifact</em> from the
previous run, which is invaluable for comparing data or model outputs
across different versions of your pipeline.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># Load the output of `mtcars_head` from yesterday&#39;s build</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>old_head <span class="ot">&lt;-</span> <span class="fu">rxp_read</span>(<span class="st">&quot;mtcars_head&quot;</span>, <span class="at">which_log =</span> <span class="st">&quot;20250814&quot;</span>)</span></code></pre></div>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>Debugging in <code>{rixpress}</code> is a systematic process
supported by a powerful set of tools. By following this workflow, you
can efficiently resolve issues in your pipelines:</p>
<ul>
<li>For runtime errors, start with <code>rxp_inspect()</code> to find
the failed derivation and its error message.</li>
<li>For logical or structural errors, use <code>rxp_trace()</code> to
understand the dependencies.</li>
<li>To speed up iteration, use <code>noop_build = TRUE</code> to isolate
the part of the pipeline you are working on.</li>
<li>For regressions, use <code>rxp_list_logs()</code> and the
<code>which_log</code> argument to travel back in time and compare
results.</li>
</ul>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
